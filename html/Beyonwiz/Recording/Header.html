<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Header</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@omen.apple.com" />
</head>

<body style="background-color: white">
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;Header</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#constants">CONSTANTS</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#prerequisites">PREREQUISITES</a></li>
	<li><a href="#bugs">BUGS</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<pre>
    use Beyonwiz::Recording::Header;</pre>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>Provides access to the Beyonwiz recording file header.</p>
<p>
</p>
<hr />
<h1><a name="constants">CONSTANTS</a></h1>
<dl>
<dt><strong><a name="item_tvhdr"><code>TVHDR</code></a></strong>

<dd>
<p>The name of the header file for a digital TV recording (<code>header.tvwiz</code>).</p>
</dd>
</li>
<dt><strong><a name="item_radhdr"><code>RADHDR</code></a></strong>

<dd>
<p>The name of the header file for a digital radio recording (<code>header.radwiz</code>).</p>
</dd>
</li>
<dt><strong><a name="item_day"><code>DAY</code></a></strong>

<dd>
<p>Number of seconds in a day. Used internally for time conversion.</p>
</dd>
</li>
<dt><strong><a name="item_max_ts_point"><code>MAX_TS_POINT</code></a></strong>

<dd>
<p>Maximum number of offsets in <em>offsets</em> (8640).</p>
</dd>
</li>
<dt><strong><a name="item_hdr_size"><code>HDR_SIZE</code></a></strong>

<dd>
<p>Total size of the header (256kiB).</p>
</dd>
</li>
<dt><strong><a name="item_hdr_main_off"><code>HDR_MAIN_OFF</code></a></strong>

<dt><strong><a name="item_hdr_main_size"><code>HDR_MAIN_SIZE</code></a></strong>

<dt><strong><a name="item_hdr_offsets_off"><code>HDR_OFFSETS_OFF</code></a></strong>

<dt><strong><a name="item_hdr_offsets_size"><code>HDR_OFFSETS_SIZE</code></a></strong>

<dt><strong><a name="item_hdr_bookmarks_off"><code>HDR_BOOKMARKS_OFF</code></a></strong>

<dt><strong><a name="item_hdr_bookmarks_sz"><code>HDR_BOOKMARKS_SZ</code></a></strong>

<dt><strong><a name="item_hdr_episode_off"><code>HDR_EPISODE_OFF</code></a></strong>

<dt><strong><a name="item_hdr_episode_sz"><code>HDR_EPISODE_SZ</code></a></strong>

<dt><strong><a name="item_hdr_extinfo_off"><code>HDR_EXTINFO_OFF</code></a></strong>

<dt><strong><a name="item_hdr_extinfo_sz"><code>HDR_EXTINFO_SZ</code></a></strong>

<dd>
<p>Offsets in the header and sizes for the sections of the header file.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="item_new"><code>Beyonwiz::Recording::Header-&gt;new()</code></a></strong>

<dd>
<p>Create a new Beyonwiz recording header object.</p>
</dd>
</li>
<dt><strong><a name="item_headername"><code>$h-&gt;headerName([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the name of the header document (path part only).</p>
</dd>
</li>
<dt><strong><code>$h-&gt;headerName([$val]);</code></strong>

<dd>
<p>Returns (sets) the name of the header document (path part only).</p>
</dd>
</li>
<dt><strong><a name="item_istv"><code>$h-&gt;isTV; $h-&gt;isRadio;</code></a></strong>

<dd>
<p>Returns true if <a href="#item_validmain"><code>$h-&gt;validMain;</code></a> is true and the recording
is digital TV (resp digital radio). Both can return false if
<a href="#item_headername"><code>$h-&gt;headerName</code></a> has not been set.</p>
</dd>
</li>
<dt><strong><a name="item_unknown"><code>$h-&gt;unknown([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the array reference of the 5 words in the header file
whose interpretation has not yet been made public.</p>
</dd>
</li>
<dt><strong><a name="item_lock"><code>$h-&gt;lock([$val]);</code></a></strong>

<dd>
<p>Returns (sets) lock flag. Possibly the flag that indicates the
recording has a parental lock set on the Beyonwiz.
Unused in WizFX.</p>
</dd>
</li>
<dt><strong><a name="item_full"><code>$h-&gt;full([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the full flag.
Purpose unknown.
Unused in WizFX.</p>
</dd>
</li>
<dt><strong><a name="item_inrec"><code>$h-&gt;inRec([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the ``currently recording'' flag.</p>
</dd>
</li>
<dt><strong><a name="item_service"><code>$h-&gt;service([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the recording service (LCN) name.</p>
</dd>
</li>
<dt><strong><a name="item_title"><code>$h-&gt;title([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the recording title (event name).
Returns the non-folder part of recording's index name if
it has no title set.</p>
</dd>
</li>
<dt><strong><a name="item_episode"><code>$h-&gt;episode([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the recording episode name (subtitle).</p>
</dd>
</li>
<dt><strong><a name="item_longtitle"><code>$h-&gt;longTitle;</code></a></strong>

<dd>
<p>Returns <a href="#item_title"><code>$h-&gt;title . '/' $h-&gt;episode</code></a> if the episode name
has been loaded and is non-empty, otherwise returns
<a href="#item_title"><code>$h-&gt;title</code></a>.</p>
</dd>
</li>
<dt><strong><a name="item_mjd"><code>$h-&gt;mjd([$val]);</code></a></strong>

<dd>
<p>Returns (sets) the recording start date.
The name suggests that it is the Modified Julian Date, but it
isn't.</p>
</dd>
<dd>
<p><code>$h-&gt;mjd == int(true_MJD + time_zone_offset_in_minutes/(24*60))</code>
where <code>time_zone_offset_in_minutes</code> is the time zone setting in
minutes current at the start of the recording.</p>
</dd>
<dd>
<p>The Beyonwiz appears to keep local time rather than UTC as its internal time.</p>
</dd>
</li>
<dt><strong><a name="item_start"><code>$h-&gt;start([$val]);</code></a></strong>

<dd>
<p>Returns (sets) number of seconds into the day indicated by <a href="#item_mjd"><code>$h-&gt;mjd</code></a>
when the recording started.</p>
</dd>
</li>
<dt><strong><a name="item_last"><code>$h-&gt;last([$val]); $h-&gt;sec([$val]);</code></a></strong>

<dd>
<p>Return (set) two parameters describing the recording duration.
The recording duration in seconds is: <a href="#item_last"><code>$self-&gt;last*10 + $self-&gt;sec</code></a>.
<a href="#item_playtime"><code>$h-&gt;playtime</code></a> is a convenience method that calculates the playtime
from <em>last</em> and <em>sec</em>.</p>
</dd>
</li>
<dt><strong><a name="item_endoffset"><code>$h-&gt;endOffset([$val]);</code></a></strong>

<dd>
<p>Return the offset of the logical end of the recording.
Returns a <code>bignum</code>.</p>
</dd>
</li>
<dt><strong><a name="item_offsets"><code>$h-&gt;offsets([$val]);</code></a></strong>

<dd>
<p>Return (set) the table of offsets (possibly at even time intervals?)
of logical file offsets (as described in <a href="#item_endoffset"><code>$h-&gt;endOffset([$val]);</code></a>).
Offsets are returned as <code>bignum</code>s.</p>
</dd>
<dd>
<p>If the offsets are at even intervals, it's probably 10 seconds.</p>
</dd>
<dd>
<p>For efficiency reasons, only populated for <code>$h-&gt;load(1)</code>.</p>
</dd>
</li>
<dt><strong><a name="item_noffsets"><code>$h-&gt;noffsets;</code></a></strong>

<dd>
<p>Returns the number of offsets.</p>
</dd>
</li>
<dt><strong><a name="item_bookmarks"><code>$h-&gt;bookmarks([$val]);</code></a></strong>

<dd>
<p>Return (set) the table of bookmarks (possibly at even time intervals?)
of logical file offsets (as described in <a href="#item_endoffset"><code>$h-&gt;endOffset([$val]);</code></a>).
Offsets are returned as <code>bignum</code>s.</p>
</dd>
<dd>
<p>For efficiency reasons, only populated for <code>$h-&gt;load(1)</code>.</p>
</dd>
</li>
<dt><strong><a name="item_nbookmarks"><code>$h-&gt;nbookmarks;</code></a></strong>

<dd>
<p>Returns the number of bookmarks.</p>
</dd>
</li>
<dt><strong><a name="item_validmain"><code>$h-&gt;validMain;</code></a></strong>

<dt><strong><a name="item_validepisode"><code>$h-&gt;validEpisode;</code></a></strong>

<dt><strong><a name="item_validextinfo"><code>$h-&gt;validExtInfo;</code></a></strong>

<dt><strong><a name="item_validbookmarks"><code>$h-&gt;validBookmarks;</code></a></strong>

<dt><strong><a name="item_validoffsets"><code>$h-&gt;validOffsets;</code></a></strong>

<dd>
<p>Returns true if the last <a href="#item_loadmain"><code>$h-&gt;loadMain;</code></a>
(resp. <a href="#item_loadepisode"><code>$h-&gt;loadEpisode</code></a>,
<a href="#item_loadextinfo"><code>$h-&gt;loadExtInfo</code></a>,
<a href="#item_loadbookmarks"><code>$h-&gt;loadBookmarks</code></a>,
or  <a href="#item_loadoffsets"><code>$h-&gt;loadOffsets</code></a>)
was successful.</p>
</dd>
</li>
<dt><strong><a name="item_size"><code>$h-&gt;size;</code></a></strong>

<dd>
<p>Returns the size of the header file (256kB).</p>
</dd>
</li>
<dt><strong><a name="item_playtime"><code>$h-&gt;playtime</code></a></strong>

<dd>
<p>A convenience method that returns the duration of
the recording in seconds.</p>
</dd>
</li>
<dt><strong><a name="item_starttime"><code>$h-&gt;starttime</code></a></strong>

<dd>
<p>Returns a Unix-like timestamp for the start time of the recording
in local time (rather than in UTC, like a true Unix timestamp).
More precisely, returns the number of seconds since midnight at the
start of 1 Jan 1970, <em>plus</em> the number of seconds in the timezone offset
at the time the recording was started.</p>
</dd>
<dd>
<p>This can be converted into the calender/clock fields for the
local time at the start of the recording using <code>gmtime</code>
(<em>not</em> <code>localtime</code>).</p>
</dd>
<dd>
<p>The local time fields can then be converted into a genuine Unix timestamp
using <code>Time::Local::timelocal</code>.</p>
</dd>
</li>
<dt><strong><a name="item_offsettime"><code>$h-&gt;offsetTime($offset)</code></a></strong>

<dd>
<p>Convert an offset into a time. <a href="#item_loadoffsets"><code>$h-&gt;loadOffsets</code></a> must have been called,
otherwise -1 is returned. Interpolates between values in the offset table.
Returns 0 if <a href="#item_offsets"><code>$offset &lt;= $self-&gt;offsets-&gt;[0]</code></a> and
<a href="#item_playtime"><code>$self-&gt;playtime</code></a> if <a href="#item_endoffset"><code>$offset &gt;= $self-&gt;endOffset</code></a>.</p>
</dd>
</li>
<dt><strong><a name="item_loadmain"><code>$h-&gt;loadMain;</code></a></strong>

<dt><strong><a name="item_loadepisode"><code>$h-&gt;loadEpisode;</code></a></strong>

<dt><strong><a name="item_loadextinfo"><code>$h-&gt;loadExtInfo;</code></a></strong>

<dt><strong><a name="item_loadbookmarks"><code>$h-&gt;loadBookmarks;</code></a></strong>

<dt><strong><a name="item_loadoffsets"><code>$h-&gt;loadOffsets;</code></a></strong>

<dd>
<p>Load parts of the header object from the header on the Beyonwiz.
<a href="#item_loadmain"><code>$h-&gt;loadMain</code></a> loads the basics,
<a href="#item_loadepisode"><code>$h-&gt;loadEpisode</code></a> loads the episode name/subtitle informtion,
<a href="#item_loadextinfo"><code>$h-&gt;loadExtInfo</code></a> loads the extended event informtion,
<a href="#item_loadbookmarks"><code>$h-&gt;loadBookmarks</code></a> loads the bookmark information
and <a href="#item_loadoffsets"><code>$h-&gt;loadOffsets</code></a> loads the 10-second offset data.</p>
</dd>
</li>
<dt><strong><a name="item_decodemain"><code>$h-&gt;decodeMain($hdr_data)</code></a></strong>

<dt><strong><a name="item_decodeepisode"><code>$h-&gt;decodeEpisode($hdr_data)</code></a></strong>

<dt><strong><a name="item_decodeextinfo"><code>$h-&gt;decodeExtInfo($hdr_data)</code></a></strong>

<dt><strong><a name="item_decodebookmarks"><code>$h-&gt;decodeBookmarks($hdr_data)</code></a></strong>

<dt><strong><a name="item_decodeoffsets"><code>$h-&gt;decodeOffsets($hdr_data)</code></a></strong>

<dd>
<p>Decodes parts of the header object from <code>$hdr_data</code> on the Beyonwiz.
The data for each part is assumed to satart at the beginning
of the respective <code>$hdr_data</code>.</p>
</dd>
<dd>
<p><a href="#item_decodemain"><code>$h-&gt;decodeMain</code></a> decodes the basics,
<a href="#item_decodeepisode"><code>$h-&gt;decodeEpisode</code></a> decodes the episode name/subtitle informtion,
<a href="#item_decodeextinfo"><code>$h-&gt;decodeExtInfo</code></a> decodes the extended event informtion,
<a href="#item_decodebookmarks"><code>$h-&gt;decodeBookmarks</code></a> decodes the bookmark information
and <a href="#item_decodeoffsets"><code>$h-&gt;decodeOffsets</code></a> decodes the 10-second offset data.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="prerequisites">PREREQUISITES</a></h1>
<p>Uses packages:
<a href="../../../html/./Beyonwiz/Utils.html"><code>Beyonwiz::Utils</code></a>,
<code>LWP::Simple</code>,
<code>URI</code>,
<code>URI::Escape</code>.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>Uses <code>bignum</code> for 64-bit integers, even when the underlying
Perl integers are 64 bits.</p>
<p>The bugs to do with time are in the Beyonwiz.</p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;Header</span></strong></big>
</td></tr>
</table>

</body>

</html>

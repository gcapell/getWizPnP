<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Beyonwiz::Recording::Header</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:_mdnsresponder@doublemagnum.apple.com" />
</head>

<body style="background-color: white">
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;Beyonwiz::Recording::Header</span></strong></big>
</td></tr>
</table>


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#constants">CONSTANTS</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#internal_methods">INTERNAL METHODS</a></li>
	<li><a href="#prerequisites">PREREQUISITES</a></li>
	<li><a href="#bugs">BUGS</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<pre>
    use Beyonwiz::Recording::Header;</pre>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>Provides access to the Beyonwiz recording file header.</p>
<p>
</p>
<hr />
<h1><a name="constants">CONSTANTS</a></h1>
<dl>
<dt><strong><a name="tvhdr" class="item"><code>TVHDR</code></a></strong></dt>

<dd>
<p>The name of the header file for a digital TV recording (<code>header.tvwiz</code>).</p>
</dd>
<dt><strong><a name="radhdr" class="item"><code>RADHDR</code></a></strong></dt>

<dd>
<p>The name of the header file for a digital radio recording (<code>header.radwiz</code>).</p>
</dd>
<dt><strong><a name="day" class="item"><code>DAY</code></a></strong></dt>

<dd>
<p>Number of seconds in a day. Used internally for time conversion.</p>
</dd>
<dt><strong><a name="max_ts_point" class="item"><code>MAX_TS_POINT</code></a></strong></dt>

<dd>
<p>Maximum number of offsets in <em>offsets</em> (8640).</p>
</dd>
<dt><strong><a name="hdr_size" class="item"><code>HDR_SIZE</code></a></strong></dt>

<dd>
<p>Total size of the header (256kiB).</p>
</dd>
<dt><strong><a name="hdr_main_off" class="item"><code>HDR_MAIN_OFF</code></a></strong></dt>

<dt><strong><a name="hdr_main_size" class="item"><code>HDR_MAIN_SIZE</code></a></strong></dt>

<dt><strong><a name="hdr_offsets_off" class="item"><code>HDR_OFFSETS_OFF</code></a></strong></dt>

<dt><strong><a name="hdr_offsets_size" class="item"><code>HDR_OFFSETS_SIZE</code></a></strong></dt>

<dt><strong><a name="hdr_bookmarks_off" class="item"><code>HDR_BOOKMARKS_OFF</code></a></strong></dt>

<dt><strong><a name="hdr_bookmarks_sz" class="item"><code>HDR_BOOKMARKS_SZ</code></a></strong></dt>

<dt><strong><a name="hdr_episode_off" class="item"><code>HDR_EPISODE_OFF</code></a></strong></dt>

<dt><strong><a name="hdr_episode_sz" class="item"><code>HDR_EPISODE_SZ</code></a></strong></dt>

<dt><strong><a name="hdr_extinfo_off" class="item"><code>HDR_EXTINFO_OFF</code></a></strong></dt>

<dt><strong><a name="hdr_extinfo_sz" class="item"><code>HDR_EXTINFO_SZ</code></a></strong></dt>

<dd>
<p>Offsets in the header and sizes for the sections of the header file.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="new" class="item"><code>Beyonwiz::Recording::Header-&gt;new($accessor, $ie)</code></a></strong></dt>

<dd>
<p>Create a new Beyonwiz recording header object.
<code>$accessor</code> is a reference to a
<a href="../../../html/./Beyonwiz/Recording/Accessor.html"><code>Beyonwiz::Recording::Accessor</code></a>
used to carry out the media file access functions in
<a href="../../../html/./Beyonwiz/Recording/Header.html"><code>Beyonwiz::Recording::Header</code></a>.
&lt;$ie&gt; is a reference to a 
<a href="../../../html/./Beyonwiz/Recording/IndexEntry.html"><code>Beyonwiz::Recording::IndexEntry</code></a>
used to retrieve name and path information for the recording.</p>
</dd>
<dt><strong><a name="accessor" class="item"><code>$h-&gt;accessor([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the media file accessor object reference.</p>
</dd>
<dt><strong><a name="ie" class="item"><code>$h-&gt;ie([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the associated
<a href="../../../html/./Beyonwiz/Recording/IndexEntry.html"><code>Beyonwiz::Recording::IndexEntry</code></a>.</p>
</dd>
<dt><strong><a name="path" class="item"><code>$h-&gt;path;</code></a></strong></dt>

<dd>
<p>Returns folder name part of the path in the associated
<a href="../../../html/./Beyonwiz/Recording/IndexEntry.html"><code>Beyonwiz::Recording::IndexEntry</code></a>.</p>
</dd>
<dt><strong><a name="name" class="item"><code>$h-&gt;name;</code></a></strong></dt>

<dd>
<p>Returns index name in the associated
<a href="../../../html/./Beyonwiz/Recording/IndexEntry.html"><code>Beyonwiz::Recording::IndexEntry</code></a>.</p>
</dd>
<dt><strong><a name="headername" class="item"><code>$h-&gt;headerName([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the name of the header document (file name part only).</p>
</dd>
<dt><strong><a name="magic" class="item"><code>$h-&gt;magic([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the header magic number (0x1062). Returns <code>undef</code>
if the header is for a media file.</p>
</dd>
<dt><strong><a name="version" class="item"><code>$h-&gt;version([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the header version number (0x1062). Returns <code>undef</code>
if the header is for a media file.</p>
</dd>
<dt><strong><a name="pids" class="item"><code>$h-&gt;pids([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) a reference to a list of Packet IDs (PIDs) for the recording.
<a href="#pids"><code>$h-&gt;pids-&gt;[0]</code></a> is the video PID,
<a href="#pids"><code>$h-&gt;pids-&gt;[1]</code></a> is the main audio pid,
<a href="#pids"><code>$h-&gt;pids-&gt;[2]</code></a> is the Program Clock Reference (PCR) PID and
<a href="#pids"><code>$h-&gt;pids-&gt;[3]</code></a> is the Program Map table PID for the recorded program.
Returns <code>[0, 0, 0, 0]</code>
if the header is for a media file.</p>
<p>The lowest-order 13 bits of the values contain the PID
<a href="#pids"><code>$h-&gt;pids-&gt;[$n] &amp; 0x1fff</code></a>.
The remaining bits are reserved for flags.
The only known flag is <code>0x8000</code> in the main audio PID,
which indicates that the audio AC3 (rather than MPEG-2).</p>
</dd>
<dt><strong><a name="pid" class="item"><code>$h-&gt;pid($n);</code>
=item <code>$h-&gt;pidFlags($n);</code></a></strong></dt>

<dd>
<p>Two utility that return, respectively,
<a href="#pids"><code>$h-&gt;pids-&gt;[$n] &amp; 0x1fff</code></a>
and
<a href="#pids"><code>$h-&gt;pids-&gt;[$n] &amp; ~0x1fff</code></a>,
the corresponding true PID value from <a href="#pids"><code>$h-&gt;pids-&gt;[$n]</code></a>
and the flags component.</p>
<p>Both methods return 0 if the header is not for a Beyonwiz recording.</p>
</dd>
<dt><strong><a name="istv" class="item"><code>$h-&gt;isTV; $h-&gt;isRadio; $h-&gt;isMediaFolder $h-&gt;isMediaFile</code></a></strong></dt>

<dd>
<p>Returns true if <a href="#validmain"><code>$h-&gt;validMain;</code></a> is true and the recording
is respectively digital TV, digital radio,
a Beyonwiz folder format for large media files,
or a single media file.
All can return false if
<a href="#headername"><code>$h-&gt;headerName</code></a> has not been set.</p>
</dd>
<dt><strong><a name="lock" class="item"><code>$h-&gt;lock([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the flag implementing the Beyonwiz File Lock on
the recording.</p>
</dd>
<dt><strong><a name="full" class="item"><code>$h-&gt;full([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the full flag.
Purpose unknown.
Unused in WizFX.</p>
</dd>
<dt><strong><a name="inrec" class="item"><code>$h-&gt;inRec([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the &quot;currently recording&quot; flag.</p>
</dd>
<dt><strong><a name="service" class="item"><code>$h-&gt;service([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the recording service (LCN) name.</p>
</dd>
<dt><strong><a name="title" class="item"><code>$h-&gt;title([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the recording title (event name).
Returns the non-folder part of recording's index name if
it has no title set.
Any leading ASCII control characters (0x00-0x1f) in the header value
are stripped off.</p>
</dd>
<dt><strong><a name="episode" class="item"><code>$h-&gt;episode([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the recording episode name (subtitle).
Any leading ASCII control characters (0x00-0x1f) in the header value
are stripped off.</p>
<p>In free-to-air EPGs, this field is sometimes used as the program
synopsis (see <a href="#extinfo"><code>$h-&gt;extInfo</code></a>), rather than the episode name.</p>
</dd>
<dt><strong><a name="extinfo" class="item"><code>$h-&gt;extInfo([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the recording extended information (program synopsis).
Any leading ASCII control characters (0x00-0x1f) in the header value
are stripped off.</p>
</dd>
<dt><strong><a name="longtitle" class="item"><code>$h-&gt;longTitle([$addEpisode[, $sep]];</code></a></strong></dt>

<dd>
<p>Returns <a href="#title"><code>$h-&gt;title . '/' . $h-&gt;episode</code></a> if the episode name
can be loaded and is non-empty, otherwise returns
<a href="#title"><code>$h-&gt;title</code></a>.
If <code>$addEpisode</code> is specified and false, the episode name is not
added in any case.
If <code>$sep</code> is specified, it is used instead of <code>'/'</code> as the separator
between title and episode name.</p>
</dd>
<dt><strong><a name="mjd" class="item"><code>$h-&gt;mjd([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) the recording start date.
The name suggests that it is the Modified Julian Date, but it
isn't.</p>
<p><code>$h-&gt;mjd == int(true_MJD + time_zone_offset_in_minutes/(24*60))</code>
where <code>time_zone_offset_in_minutes</code> is the time zone setting in
minutes current at the start of the recording.</p>
<p>The Beyonwiz appears to keep local time rather than UTC as its internal time.</p>
</dd>
<dt><strong><a name="start" class="item"><code>$h-&gt;start([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) number of seconds into the day indicated by <a href="#mjd"><code>$h-&gt;mjd</code></a>
when the recording started.</p>
</dd>
<dt><strong><a name="last" class="item"><code>$h-&gt;last([$val]); $h-&gt;sec([$val]);</code></a></strong></dt>

<dd>
<p>Return (set) two parameters describing the recording duration.
The recording duration in seconds is: <a href="#last"><code>$self-&gt;last*10 + $self-&gt;sec</code></a>.
<a href="#playtime"><code>$h-&gt;playtime</code></a> is a convenience method that calculates the playtime
from <em>last</em> and <em>sec</em>.</p>
</dd>
<dt><strong><a name="endoffset" class="item"><code>$h-&gt;endOffset([$val]);</code></a></strong></dt>

<dd>
<p>Return the offset of the logical end of the recording.
Returns a <code>bignum</code>.</p>
</dd>
<dt><strong><a name="offsets" class="item"><code>$h-&gt;offsets([$val]);</code></a></strong></dt>

<dd>
<p>Return (set) the table of offsets (possibly at even time intervals?)
of logical file offsets (as described in <a href="#endoffset"><code>$h-&gt;endOffset([$val]);</code></a>).
Offsets are returned as <code>bignum</code>s.</p>
<p>If the offsets are at even intervals, it's probably 10 seconds.</p>
<p>For efficiency reasons, only populated for <code>$h-&gt;load(1)</code>.</p>
</dd>
<dt><strong><a name="noffsets" class="item"><code>$h-&gt;noffsets;</code></a></strong></dt>

<dd>
<p>Returns the number of offsets.</p>
</dd>
<dt><strong><a name="bookmarks" class="item"><code>$h-&gt;bookmarks([$val]);</code></a></strong></dt>

<dd>
<p>Return (set) the table of bookmarks (possibly at even time intervals?)
of logical file offsets (as described in <a href="#endoffset"><code>$h-&gt;endOffset([$val]);</code></a>).
Offsets are returned as <code>bignum</code>s.</p>
<p>For efficiency reasons, only populated for <code>$h-&gt;load(1)</code>.</p>
</dd>
<dt><strong><a name="nbookmarks" class="item"><code>$h-&gt;nbookmarks;</code></a></strong></dt>

<dd>
<p>Returns the number of bookmarks.</p>
</dd>
<dt><strong><a name="validmain" class="item"><code>$h-&gt;validMain;</code></a></strong></dt>

<dt><strong><a name="validepisode" class="item"><code>$h-&gt;validEpisode;</code></a></strong></dt>

<dt><strong><a name="validextinfo" class="item"><code>$h-&gt;validExtInfo;</code></a></strong></dt>

<dt><strong><a name="validbookmarks" class="item"><code>$h-&gt;validBookmarks;</code></a></strong></dt>

<dt><strong><a name="validoffsets" class="item"><code>$h-&gt;validOffsets;</code></a></strong></dt>

<dd>
<p>Returns true if the last <a href="#loadmain"><code>$h-&gt;loadMain;</code></a>
(resp. <a href="#loadepisode"><code>$h-&gt;loadEpisode</code></a>,
<a href="#loadextinfo"><code>$h-&gt;loadExtInfo</code></a>,
<a href="#loadbookmarks"><code>$h-&gt;loadBookmarks</code></a>,
or  <a href="#loadoffsets"><code>$h-&gt;loadOffsets</code></a>)
was successful.</p>
</dd>
<dt><strong><a name="reconstructed" class="item"><code>$s-&gt;reconstructed([$val]);</code></a></strong></dt>

<dd>
<p>Returns (sets) a flag marking that the object represents a reconstructed
file, and the file should be encoded from the object rather than being
copied from the source.</p>
<p>There is no general reconstruction method for
<a href="../../../html/./Beyonwiz/Recording/Header.html"><code>Beyonwiz::Recording::Header</code></a>,
but reconstruction of other headers may need to modify the header object,
and they should set this flag when the header is modified.</p>
<p>Reset by any call of <a href="#loadmain"><code>$h-&gt;loadMain</code></a>,
<a href="#loadepisode"><code>$h-&gt;loadEpisode</code></a>,
<a href="#loadextinfo"><code>$h-&gt;loadExtInfo</code></a>,
<a href="#loadbookmarks"><code>$h-&gt;loadBookmarks</code></a>,
or  <a href="#loadoffsets"><code>$h-&gt;loadOffsets</code></a>.</p>
</dd>
<dt><strong><a name="size" class="item"><code>$h-&gt;size;</code></a></strong></dt>

<dd>
<p>Returns the size of the header file (256kB).</p>
</dd>
<dt><strong><a name="playtime" class="item"><code>$h-&gt;playtime</code></a></strong></dt>

<dd>
<p>A convenience method that returns the duration of
the recording in seconds.</p>
</dd>
<dt><strong><a name="filelentime" class="item"><code>$h-&gt;fileLenTime([$file])</code></a></strong></dt>

<dd>
<p>Return the tuple <em>($len, $modifyTime)</em> for the trunc file.
The modify time is a Unix timestamp (seconds since 00:00:00) Jan 1 1970 UTC).
If <code>$file</code> is specified, use that as the name of the trunc file,
otherwise use <code>$t-</code>headerName&gt; for the name of the file.
Returns <code>undef</code> if the data can't be found
(access denied or file not found).</p>
</dd>
<dt><strong><a name="starttime" class="item"><code>$h-&gt;starttime</code></a></strong></dt>

<dd>
<p>Returns a Unix-like timestamp for the start time of the recording
in local time (rather than in UTC, like a true Unix timestamp).
More precisely, returns the number of seconds since midnight at the
start of 1 Jan 1970, <em>plus</em> the number of seconds in the timezone offset
at the time the recording was started.</p>
<p>This can be converted into the calender/clock fields for the
local time at the start of the recording using <code>gmtime</code>
(<em>not</em> <code>localtime</code>).</p>
<p>The local time fields can then be converted into a genuine Unix timestamp
using <code>Time::Local::timelocal</code>.</p>
</dd>
<dt><strong><a name="offsettime" class="item"><code>$h-&gt;offsetTime($offset)</code></a></strong></dt>

<dd>
<p>Convert an offset into a time. <a href="#loadoffsets"><code>$h-&gt;loadOffsets</code></a> must have been called,
otherwise -1 is returned. Interpolates between values in the offset table.
Returns 0 if <a href="#offsets"><code>$offset &lt;= $self-&gt;offsets-&gt;[0]</code></a> and
<a href="#playtime"><code>$self-&gt;playtime</code></a> if <a href="#endoffset"><code>$offset &gt;= $self-&gt;endOffset</code></a>.</p>
</dd>
<dt><strong><a name="updateoffsets" class="item"><code>$h-&gt;updateOffsets($newStart, $newEnd)</code></a></strong></dt>

<dd>
<p>Update the offsets so that <a href="#endoffset"><code>$h-&gt;endOffset;</code></a> is set to <code>$newEnd</code>
and the offset table is adjusted to start at <code>$newStart</code>.
Intended to be used when the trunc header has been reconstructed.</p>
</dd>
<dt><strong><a name="loadmain" class="item"><code>$h-&gt;loadMain;</code></a></strong></dt>

<dt><strong><a name="loadhdrwmmeta" class="item"><code>$h-&gt;loadHdrWmmeta;</code></a></strong></dt>

<dt><strong><a name="loadhdrfile" class="item"><code>$h-&gt;loadHdrFile;</code></a></strong></dt>

<dt><strong><a name="loadepisode" class="item"><code>$h-&gt;loadEpisode;</code></a></strong></dt>

<dt><strong><a name="loadextinfo" class="item"><code>$h-&gt;loadExtInfo;</code></a></strong></dt>

<dt><strong><a name="loadbookmarks" class="item"><code>$h-&gt;loadBookmarks;</code></a></strong></dt>

<dt><strong><a name="loadoffsets" class="item"><code>$h-&gt;loadOffsets;</code></a></strong></dt>

<dd>
<p>Load parts of the header object from the header on the Beyonwiz.
<a href="#loadmain"><code>$h-&gt;loadMain</code></a> loads the basics,
<a href="#loadepisode"><code>$h-&gt;loadEpisode</code></a> loads the episode name/subtitle informtion,
<a href="#loadextinfo"><code>$h-&gt;loadExtInfo</code></a> loads the extended event informtion,
<a href="#loadbookmarks"><code>$h-&gt;loadBookmarks</code></a> loads the bookmark information
and <a href="#loadoffsets"><code>$h-&gt;loadOffsets</code></a> loads the 10-second offset data.</p>
<p><a href="#loadhdrwmmeta"><code>$h-&gt;loadHdrWmmeta;</code></a> and <a href="#loadhdrfile"><code>$h-&gt;loadHdrFile;</code></a> load as
much of the header as possible with information about media
content either in the Beyonwiz folder format for large
files (<a href="#loadhdrwmmeta"><code>$h-&gt;loadHdrWmmeta;</code></a>),
or in single files (<a href="#loadhdrfile"><code>$h-&gt;loadHdrFile;</code></a>).</p>
</dd>
<dt><strong><a name="decodemain" class="item"><code>$h-&gt;decodeMain($hdr_data)</code></a></strong></dt>

<dt><strong><a name="decodeepisode" class="item"><code>$h-&gt;decodeEpisode($hdr_data)</code></a></strong></dt>

<dt><strong><a name="decodeextinfo" class="item"><code>$h-&gt;decodeExtInfo($hdr_data)</code></a></strong></dt>

<dt><strong><a name="decodebookmarks" class="item"><code>$h-&gt;decodeBookmarks($hdr_data)</code></a></strong></dt>

<dt><strong><a name="decodeoffsets" class="item"><code>$h-&gt;decodeOffsets($hdr_data)</code></a></strong></dt>

<dd>
<p>Decodes parts of the header object from <code>$hdr_data</code> on the Beyonwiz.
The data for each part is assumed to satart at the beginning
of the respective <code>$hdr_data</code>.</p>
</dd>
<dt><strong><a name="encodemain" class="item"><code>$h-&gt;encodeMain</code></a></strong></dt>

<dt><strong><a name="encodeepisode" class="item"><code>$h-&gt;encodeEpisode</code></a></strong></dt>

<dt><strong><a name="encodeextinfo" class="item"><code>$h-&gt;encodeExtInfo</code></a></strong></dt>

<dt><strong><a name="encodebookmarks" class="item"><code>$h-&gt;encodeBookmarks</code></a></strong></dt>

<dt><strong><a name="encodeoffsets" class="item"><code>$h-&gt;encodeOffsets</code></a></strong></dt>

<dd>
<p>Encodes parts of the header object ready for writing back
to a header file. The methods encode the corresponding data to the decode
functions above.</p>
</dd>
<dt><strong><code>$h-&gt;encodeMain</code></strong></dt>

<dd>
<p>Encodes the header object ready for writing back
to a header file.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="internal_methods">INTERNAL METHODS</a></h1>
<dl>
<dt><strong><a name="_setunixtime" class="item"><code>$h-&gt;_setUnixTime($time);</code></a></strong></dt>

<dd>
<p>Set <a href="#mjd"><code>$h-&gt;mjd([$val]);</code></a> and <a href="#start"><code>$h-&gt;start([$val]);</code></a>
from the given Unix time (seconds since 00:00:00 Jan 1 1097 UTC).</p>
</dd>
<dt><strong><a name="_setmainmediafile" class="item"><code>$h-&gt;_setMainMediaFile($size, $time);</code></a></strong></dt>

<dd>
<p>Set as many fields as possible to reasonable values given the
size and timestamp of a media file.</p>
</dd>
<dt><strong><a name="_readhdrchunk" class="item"><code>$h-&gt;_readHdrChunk($offset, $size);</code></a></strong></dt>

<dd>
<p>Read a chunk of the header file.
Reads from <a href="#headername"><code>$h-&gt;headerName([$val]);</code></a> if it
is defined, otherwise tries reading from
<a href="#tvhdr"><code>/TVHDR</code></a> then <a href="#radhdr"><code>/RADHDR</code></a> and sets
the header name from the first to succeed.
Reads <code>$size</code> bytes at byte offst <code>$offset</code>
from the start of the header file.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="prerequisites">PREREQUISITES</a></h1>
<p>Uses packages:
<a href="../../../html/./Beyonwiz/Utils.html"><code>Beyonwiz::Utils</code></a>,
<a href="../../../html/./Beyonwiz/Recording/Trunc.html"><code>Beyonwiz::Recording::Trunc</code></a>;
<code>LWP::Simple</code>,
<code>URI</code>,
<code>URI::Escape</code>,
<code>Time::Local</code>,
<code>File::Basename</code>.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>Uses <code>bignum</code> for 64-bit integers, even when the underlying
Perl integers are 64 bits.</p>
<p>The bugs to do with time are in the Beyonwiz.</p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;Beyonwiz::Recording::Header</span></strong></big>
</td></tr>
</table>

</body>

</html>
